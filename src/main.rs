// SPDX-FileCopyrightText: 2020 Robin Krahl <robin.krahl@ireas.org>
// SPDX-License-Identifier: MIT

mod doc;
mod index;
mod parser;
mod source;
mod viewer;

use std::io;
use std::path;

use structopt::StructOpt;

/// Command-line interface for rustdoc documentation
#[derive(Debug, StructOpt)]
struct Opt {
    /// The keyword to open the documentation for, e. g. `rand_core::RngCore`
    keyword: String,

    /// The sources to check for documentation generated by rustdoc
    ///
    /// Typically, this is the path of a directory containing the documentation for one or more
    /// crates in subdirectories.
    #[structopt(name = "source", short, long, number_of_values = 1)]
    source_paths: Vec<String>,

    /// The viewer for the rustdoc documentation
    #[structopt(long, parse(try_from_str = viewer::get_viewer))]
    viewer: Option<Box<dyn viewer::Viewer>>,

    /// Do not search the default documentation sources
    ///
    /// If this option is not set, rusty-man appends `/usr/share/doc/rust{,-doc}/html` and
    /// `target/doc` directory to the list of sources if they exist.
    #[structopt(long)]
    no_default_sources: bool,
}

fn main() -> anyhow::Result<()> {
    let opt = Opt::from_args();
    let sources = load_sources(&opt.source_paths, !opt.no_default_sources)?;
    let doc = if let Some(doc) = find_doc(&sources, &opt.keyword)? {
        Some(doc)
    } else {
        search_doc(&sources, &opt.keyword)?
    };

    if let Some(doc) = doc {
        let viewer = opt.viewer.unwrap_or_else(viewer::get_default);
        viewer.open(&doc)
    } else {
        // item selection cancelled by user
        Ok(())
    }
}

const DEFAULT_SOURCES: &[&str] = &[
    "/usr/share/doc/rust/html",
    "/usr/share/doc/rust-doc/html",
    "./target/doc",
];

fn load_sources(
    sources: &[String],
    load_default_sources: bool,
) -> anyhow::Result<Vec<Box<dyn source::Source>>> {
    let mut vec: Vec<Box<dyn source::Source>> = Vec::new();

    if load_default_sources {
        for s in DEFAULT_SOURCES {
            let path: &path::Path = s.as_ref();
            if path.is_dir() {
                vec.push(source::get_source(path)?);
            }
        }
    }

    for s in sources {
        vec.push(source::get_source(s)?);
    }

    // The last source should be searched first --> reverse source vector
    vec.reverse();

    Ok(vec)
}

fn find_doc(
    sources: &[Box<dyn source::Source>],
    keyword: &str,
) -> anyhow::Result<Option<doc::Doc>> {
    let parts: Vec<&str> = keyword.split("::").collect();
    if let Some(crate_) = find_crate(sources, parts[0]) {
        crate_
            .find_item(&parts[1..])?
            .or_else(|| crate_.find_module(&parts[1..]))
            .or_else(|| crate_.find_member(&parts[1..]))
            .map(|i| i.load_doc())
            .transpose()
    } else {
        Ok(None)
    }
}

fn find_crate(sources: &[Box<dyn source::Source>], name: &str) -> Option<doc::Crate> {
    sources.iter().filter_map(|s| s.find_crate(name)).next()
}

fn search_doc(
    sources: &[Box<dyn source::Source>],
    keyword: &str,
) -> anyhow::Result<Option<doc::Doc>> {
    if let Some(item) = search_item(sources, keyword)? {
        use anyhow::Context;

        let item = format!("{}::{}", item.path, item.name);
        let doc = find_doc(sources, &item)?
            .with_context(|| format!("Could not find documentation for {}", &item))?;
        Ok(Some(doc))
    } else {
        Ok(None)
    }
}

fn search_item(
    sources: &[Box<dyn source::Source>],
    keyword: &str,
) -> anyhow::Result<Option<index::IndexItem>> {
    let indexes = sources
        .iter()
        .filter_map(|s| s.load_index().transpose())
        .collect::<anyhow::Result<Vec<_>>>()?;
    let mut items = indexes
        .iter()
        .map(|i| i.find(keyword))
        .collect::<Vec<_>>()
        .concat();
    items.sort_unstable();
    items.dedup();

    if items.is_empty() {
        Err(anyhow::anyhow!(
            "Could not find documentation for {}",
            &keyword
        ))
    } else if items.len() == 1 {
        Ok(Some(items[0].clone()))
    } else {
        select_item(&items, keyword)
    }
}

fn select_item(
    items: &[index::IndexItem],
    keyword: &str,
) -> anyhow::Result<Option<index::IndexItem>> {
    use std::io::Write;

    // If we are not on a TTY, we can’t ask the user to select an item --> abort
    anyhow::ensure!(
        termion::is_tty(&io::stdin()),
        "Found multiple matches for {}",
        keyword
    );

    println!("Found mulitple matches for {} – select one of:", keyword);
    println!();
    let width = (items.len() + 1).to_string().len();
    for (i, item) in items.iter().enumerate() {
        println!("[ {:width$} ] {}", i, &item, width = width);
    }
    println!();
    print!("> ");
    io::stdout().flush()?;

    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    if let Ok(i) = usize::from_str_radix(input.trim(), 10) {
        Ok(items.get(i).map(Clone::clone))
    } else {
        Ok(None)
    }
}

#[cfg(test)]
mod tests {
    use std::path;

    use crate::source;

    pub fn ensure_docs() -> path::PathBuf {
        let doc = path::PathBuf::from("./target/doc");
        assert!(
            doc.is_dir(),
            "You have to run `cargo doc` before running this test case."
        );
        doc
    }

    #[test]
    fn test_find_doc() {
        let path = ensure_docs();
        let sources = vec![source::get_source(path).unwrap()];

        assert!(super::find_doc(&sources, "kuchiki").unwrap().is_some());
        assert!(super::find_doc(&sources, "kuchiki::NodeRef")
            .unwrap()
            .is_some());
        assert!(super::find_doc(&sources, "kuchiki::NodeDataRef::as_node")
            .unwrap()
            .is_some());
        assert!(super::find_doc(&sources, "kuchiki::traits")
            .unwrap()
            .is_some());
        assert!(super::find_doc(&sources, "kachiki").unwrap().is_none());
    }
}
