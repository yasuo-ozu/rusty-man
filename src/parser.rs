// SPDX-FileCopyrightText: 2020 Robin Krahl <robin.krahl@ireas.org>
// SPDX-License-Identifier: MIT

//! Parses HTML files generated by rustdoc.
//!
//! For details on the format of the parsed HTML files, check the following items in the
//! `html::render` module of `librustdoc` (in the Rust source):
//! - The `krate` and `render_item` methods of the `Context` struct are the main entry points for
//!   the rendering.
//! - The `print_item` and `item_*`functions generate the HTML for an item (module, struct, â€¦).
//! - The `AllTypes::print` function generates the HTML for the `all.html` page using the
//!   `print_entries` function.

use std::path;

use anyhow::Context;

use crate::doc;

/// Parses the HTML document at the given path and returns the DOM.
fn parse_file<P: AsRef<path::Path>>(path: P) -> anyhow::Result<kuchiki::NodeRef> {
    use kuchiki::traits::TendrilSink;

    kuchiki::parse_html()
        .from_utf8()
        .from_file(path)
        .context("Could not read HTML file")
}

pub fn find_item<P: AsRef<path::Path>>(path: P, item: &str) -> anyhow::Result<Option<String>> {
    use std::ops::Deref;

    let document = parse_file(path)?;
    let item = select(&document, "ul.docblock li a")?
        .find(|e| e.text_contents() == item)
        .and_then(|e| get_attribute(e.deref(), "href"));
    Ok(item)
}

pub fn find_member<P: AsRef<path::Path>>(path: P, item: &str) -> anyhow::Result<bool> {
    let document = parse_file(path)?;
    Ok(get_member(&document, item)?.is_some())
}

fn select(
    element: &kuchiki::NodeRef,
    selector: &str,
) -> anyhow::Result<kuchiki::iter::Select<kuchiki::iter::Elements<kuchiki::iter::Descendants>>> {
    element
        .select(selector)
        .ok()
        .with_context(|| format!("Could not apply selector {}", selector))
}

fn select_first(
    element: &kuchiki::NodeRef,
    selector: &str,
) -> anyhow::Result<Option<kuchiki::NodeDataRef<kuchiki::ElementData>>> {
    select(element, selector).map(|mut i| i.next())
}

const ITEM_MEMBERS: &[(&str, &str)] = &[
    ("Extern Crates", "extern-crates"),
    ("Imports", "imports"),
    ("Primitives", "primitives"),
    ("Modules", "modules"),
    ("Macros", "macros"),
    ("Structs", "structs"),
    ("Enums", "enums"),
    ("Constants", "constants"),
    ("Statics", "statics"),
    ("Traits", "traits"),
    ("Functions", "functions"),
    ("Typedefs", "typedefs"),
    ("Unions", "unions"),
];

pub fn parse_item_doc<P: AsRef<path::Path>>(path: P, name: &doc::Fqn) -> anyhow::Result<doc::Doc> {
    let document = parse_file(path)?;
    let heading = select_first(&document, ".fqn .in-band")?.context("Could not find heading")?;
    let definition = select_first(&document, ".docblock.type-decl")?;
    let description = select_first(&document, ".docblock:not(.type-decl)")?;

    let mut doc = doc::Doc::new(name.clone());
    doc.title = Some(get_html(heading.as_node())?);
    doc.description = description.map(|n| get_html(n.as_node())).transpose()?;
    doc.definition = definition.map(|n| get_html(n.as_node())).transpose()?;
    for (heading, id) in ITEM_MEMBERS {
        let members = get_members(&document, name, id)?;
        if !members.is_empty() {
            doc.members.push((heading.to_string(), members));
        }
    }
    Ok(doc)
}

pub fn parse_member_doc<P: AsRef<path::Path>>(
    path: P,
    name: &doc::Fqn,
) -> anyhow::Result<doc::Doc> {
    let document = parse_file(path)?;
    let member = get_member(&document, name.last())?
        .with_context(|| format!("Could not find member {}", name))?;
    let heading = member
        .as_node()
        .parent()
        .with_context(|| format!("The member {} does not have a parent", name))?;
    let docblock = heading.next_sibling();

    let mut doc = doc::Doc::new(name.clone());
    doc.definition = Some(get_html(member.as_node())?);
    doc.description = docblock.map(|n| get_html(&n)).transpose()?;
    Ok(doc)
}

fn get_members(
    document: &kuchiki::NodeRef,
    base_name: &doc::Fqn,
    id: &str,
) -> anyhow::Result<Vec<doc::Doc>> {
    let mut members: Vec<doc::Doc> = Vec::new();
    if let Some(table) = select_first(document, &format!("#{} + table", id))? {
        // On module pages, the members are listed in tables
        let items = select(table.as_node(), "td:first-child :first-child")?;
        for item in items {
            let item_name = get_html(item.as_node())?;
            members.push(doc::Doc::new(base_name.child(&item_name)))
        }
    }
    Ok(members)
}

fn get_member(
    document: &kuchiki::NodeRef,
    name: &str,
) -> anyhow::Result<Option<kuchiki::NodeDataRef<kuchiki::ElementData>>> {
    document
        .select(&format!("#{}\\.v", name))
        .ok()
        .context("Could not select member by id")
        .map(|mut i| i.next())
}

fn get_attribute(element: &kuchiki::ElementData, name: &str) -> Option<String> {
    element.attributes.borrow().get(name).map(ToOwned::to_owned)
}

fn get_html(node: &kuchiki::NodeRef) -> anyhow::Result<String> {
    let mut vec: Vec<u8> = Vec::new();
    node.serialize(&mut vec)?;
    String::from_utf8(vec).context("Could not convert node to HTML")
}

#[cfg(test)]
mod tests {
    use crate::doc;

    #[test]
    fn test_find_item() {
        let path = crate::tests::ensure_docs();
        let path = path.join("kuchiki").join("all.html");
        assert_eq!(None, super::find_item(&path, "foobar").unwrap());
        assert_eq!(
            Some("struct.NodeRef.html".to_owned()),
            super::find_item(&path, "NodeRef").unwrap()
        );
    }

    #[test]
    fn test_parse_item_doc() {
        let path = crate::tests::ensure_docs();
        let path = path.join("kuchiki").join("struct.NodeRef.html");
        let name: doc::Fqn = "kuchiki::NodeRef".to_owned().into();
        let doc = super::parse_item_doc(&path, &name).unwrap();

        assert_eq!(name, doc.name);
        assert_eq!(
            "<span class=\"in-band\">\
             Struct <a href=\"index.html\">kuchiki</a>::<wbr>\
             <a class=\"struct\" href=\"\">NodeRef</a>\
             </span>",
            &doc.title.unwrap()
        );
        assert!(doc.definition.is_some());
        assert!(doc.description.is_some());
    }

    #[test]
    fn test_parse_member_doc() {
        let path = crate::tests::ensure_docs();
        let path = path.join("kuchiki").join("struct.NodeDataRef.html");
        let name: doc::Fqn = "kuchiki::NodeDataRef::as_node".to_owned().into();
        let doc = super::parse_member_doc(&path, &name).unwrap();

        assert_eq!(name, doc.name);
        assert!(doc.title.is_none());
        assert_eq!(
            "<code id=\"as_node.v\">\
             pub fn <a class=\"fnname\" href=\"#method.as_node\">as_node</a>(&amp;self) \
             -&gt; &amp;<a class=\"struct\" href=\"../kuchiki/struct.NodeRef.html\" \
             title=\"struct kuchiki::NodeRef\">NodeRef</a></code>",
            &doc.definition.unwrap()
        );
        assert!(doc.description.is_some());
    }
}
