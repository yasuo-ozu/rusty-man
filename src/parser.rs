// SPDX-FileCopyrightText: 2020 Robin Krahl <robin.krahl@ireas.org>
// SPDX-License-Identifier: MIT

//! Parses HTML files generated by rustdoc.
//!
//! For details on the format of the parsed HTML files, check the following items in the
//! `html::render` module of `librustdoc` (in the Rust source):
//! - The `krate` and `render_item` methods of the `Context` struct are the main entry points for
//!   the rendering.
//! - The `print_item` and `item_*`functions generate the HTML for an item (module, struct, â€¦).
//! - The `AllTypes::print` function generates the HTML for the `all.html` page using the
//!   `print_entries` function.

use std::path;

use anyhow::Context;

use crate::doc;

/// Parses the HTML document at the given path and returns the DOM.
fn parse_file<P: AsRef<path::Path>>(path: P) -> anyhow::Result<kuchiki::NodeRef> {
    use kuchiki::traits::TendrilSink;

    kuchiki::parse_html()
        .from_utf8()
        .from_file(path)
        .context("Could not read HTML file")
}

pub fn find_item<P: AsRef<path::Path>>(path: P, item: &str) -> anyhow::Result<Option<String>> {
    use std::ops::Deref;

    let document = parse_file(path)?;
    let item = select(&document, "ul.docblock li a")?
        .find(|e| e.text_contents() == item)
        .and_then(|e| get_attribute(e.deref(), "href"));
    Ok(item)
}

pub fn find_member<P: AsRef<path::Path>>(
    path: P,
    name: &doc::Fqn,
) -> anyhow::Result<Option<doc::Item>> {
    let document = parse_file(path.as_ref())?;
    if let Some(member) = get_member(&document, name.last())? {
        let parent = member
            .as_node()
            .parent()
            .context("Member element does not have a parent")?;
        if let Some(parent_id) = get_node_attribute(&parent, "id") {
            let item_type: doc::ItemType = parent_id.splitn(2, '.').next().unwrap().parse()?;
            return Ok(Some(doc::Item::new(
                name.clone(),
                path.as_ref().to_owned(),
                item_type,
            )));
        }
    }
    Ok(None)
}

fn select(
    element: &kuchiki::NodeRef,
    selector: &str,
) -> anyhow::Result<kuchiki::iter::Select<kuchiki::iter::Elements<kuchiki::iter::Descendants>>> {
    element
        .select(selector)
        .ok()
        .with_context(|| format!("Could not apply selector {}", selector))
}

fn select_first(
    element: &kuchiki::NodeRef,
    selector: &str,
) -> anyhow::Result<Option<kuchiki::NodeDataRef<kuchiki::ElementData>>> {
    select(element, selector).map(|mut i| i.next())
}

pub fn parse_item_doc(item: &doc::Item) -> anyhow::Result<doc::Doc> {
    let document = parse_file(&item.path)?;
    let definition = select_first(&document, ".docblock.type-decl")?;
    let description = select_first(&document, "#main > .docblock:not(.type-decl)")?;

    let mut doc = doc::Doc::new(item.name.clone(), item.ty);
    doc.description = description.map(|n| get_html(n.as_node())).transpose()?;
    doc.definition = definition.map(|n| get_html(n.as_node())).transpose()?;

    let (ty, groups) = get_variants(&document, item)?;
    if !groups.is_empty() {
        doc.groups.push((ty, groups));
    }
    let (ty, groups) = get_assoc_types(&document, item)?;
    if !groups.is_empty() {
        doc.groups.push((ty, groups));
    }
    let (ty, groups) = get_methods(&document, item)?;
    if !groups.is_empty() {
        doc.groups.push((ty, groups));
    }

    Ok(doc)
}

const MODULE_MEMBER_TYPES: &[doc::ItemType] = &[
    doc::ItemType::ExternCrate,
    doc::ItemType::Import,
    doc::ItemType::Primitive,
    doc::ItemType::Module,
    doc::ItemType::Macro,
    doc::ItemType::Struct,
    doc::ItemType::Enum,
    doc::ItemType::Constant,
    doc::ItemType::Static,
    doc::ItemType::Trait,
    doc::ItemType::Function,
    doc::ItemType::Typedef,
    doc::ItemType::Union,
];

pub fn parse_module_doc(item: &doc::Item) -> anyhow::Result<doc::Doc> {
    let document = parse_file(&item.path)?;
    let description = select_first(&document, ".docblock")?;

    let mut doc = doc::Doc::new(item.name.clone(), item.ty);
    doc.description = description.map(|n| get_html(n.as_node())).transpose()?;
    for item_type in MODULE_MEMBER_TYPES {
        let mut group = doc::MemberGroup::new(None);
        group.members = get_members(&document, item, *item_type)?;
        if !group.members.is_empty() {
            doc.groups.push((*item_type, vec![group]));
        }
    }
    Ok(doc)
}

pub fn parse_member_doc(item: &doc::Item) -> anyhow::Result<doc::Doc> {
    let document = parse_file(&item.path)?;
    let member = get_member(&document, item.name.last())?
        .with_context(|| format!("Could not find member {}", &item.name))?;
    let heading = member
        .as_node()
        .parent()
        .with_context(|| format!("The member {} does not have a parent", &item.name))?;
    let docblock = heading.next_sibling();

    let mut doc = doc::Doc::new(item.name.clone(), item.ty);
    doc.definition = Some(get_html(member.as_node())?);
    doc.description = docblock.map(|n| get_html(&n)).transpose()?;
    Ok(doc)
}

fn get_methods(
    document: &kuchiki::NodeRef,
    parent: &doc::Item,
) -> anyhow::Result<(doc::ItemType, Vec<doc::MemberGroup>)> {
    let ty = doc::ItemType::Method;
    let mut groups: Vec<doc::MemberGroup> = Vec::new();
    let heading = select_first(document, &format!("#{}", ty.group_id()))?;

    let mut next = heading.and_then(|n| next_sibling_element(n.as_node()));
    while let Some(subheading) = &next {
        if is_element(subheading, &markup5ever::local_name!("h3")) && has_class(subheading, "impl")
        {
            if let Some(title_element) = subheading.first_child() {
                let title = get_html(&title_element)?;
                next = subheading.next_sibling();
                if let Some(impl_items) = &next {
                    if is_element(impl_items, &markup5ever::local_name!("div"))
                        && has_class(impl_items, "impl-items")
                    {
                        let group = get_method_group(
                            parent,
                            Some(title),
                            &impl_items,
                            doc::ItemType::Method,
                            markup5ever::local_name!("h4"),
                        )?;
                        if !group.members.is_empty() {
                            groups.push(group);
                        }
                        next = impl_items.next_sibling();
                    }
                }
            } else {
                next = None;
            }
        } else {
            next = None;
        }
    }

    let heading = select_first(document, "#deref-methods")?;
    if let Some(heading) = heading {
        let title = get_html(heading.as_node())?;
        if let Some(impl_items) = heading.as_node().next_sibling() {
            let group = get_method_group(
                parent,
                Some(title),
                &impl_items,
                doc::ItemType::Method,
                markup5ever::local_name!("h4"),
            )?;
            if !group.members.is_empty() {
                groups.push(group);
            }
        }
    }

    let heading = select_first(document, "#required-methods")?;
    if let Some(heading) = heading {
        if let Some(methods) = heading.as_node().next_sibling() {
            let title = "Required Methods".to_owned();
            let group = get_method_group(
                parent,
                Some(title),
                &methods,
                doc::ItemType::TyMethod,
                markup5ever::local_name!("h3"),
            )?;
            if !group.members.is_empty() {
                groups.push(group);
            }
        }
    }

    let heading = select_first(document, "#provided-methods")?;
    if let Some(heading) = heading {
        if let Some(methods) = heading.as_node().next_sibling() {
            let title = "Provided Methods".to_owned();
            let group = get_method_group(
                parent,
                Some(title),
                &methods,
                doc::ItemType::TyMethod,
                markup5ever::local_name!("h3"),
            )?;
            if !group.members.is_empty() {
                groups.push(group);
            }
        }
    }

    Ok((ty, groups))
}

fn get_assoc_types(
    document: &kuchiki::NodeRef,
    parent: &doc::Item,
) -> anyhow::Result<(doc::ItemType, Vec<doc::MemberGroup>)> {
    let ty = doc::ItemType::AssocType;
    let mut groups: Vec<doc::MemberGroup> = Vec::new();

    let heading = select_first(document, "#associated-types")?;
    if let Some(heading) = heading {
        if let Some(methods) = heading.as_node().next_sibling() {
            let group = get_method_group(
                parent,
                None,
                &methods,
                doc::ItemType::AssocType,
                markup5ever::local_name!("h3"),
            )?;
            if !group.members.is_empty() {
                groups.push(group);
            }
        }
    }

    Ok((ty, groups))
}

fn get_method_group(
    parent: &doc::Item,
    title: Option<String>,
    impl_items: &kuchiki::NodeRef,
    ty: doc::ItemType,
    heading_type: markup5ever::LocalName,
) -> anyhow::Result<doc::MemberGroup> {
    let mut group = doc::MemberGroup::new(title);

    let mut name: Option<String> = None;
    let mut definition: Option<String> = None;
    for element in impl_items.children() {
        if is_element(&element, &heading_type) && has_class(&element, "method") {
            if let Some(name) = name {
                let mut doc = doc::Doc::new(parent.name.child(&name), ty);
                doc.definition = definition;
                group.members.push(doc);
            }
            name = get_node_attribute(&element, "id")
                .and_then(|a| a.splitn(2, '.').nth(1).map(ToOwned::to_owned));
            definition = element.first_child().map(|n| get_html(&n)).transpose()?;
        } else if is_element(&element, &markup5ever::local_name!("div"))
            && has_class(&element, "docblock")
        {
            // TODO: inner html
            if let Some(name) = name {
                let mut doc = doc::Doc::new(parent.name.child(&name), ty);
                doc.definition = definition;
                doc.description = element.first_child().map(|n| n.text_contents());
                group.members.push(doc);
            }
            name = None;
            definition = None;
        }
    }

    Ok(group)
}

fn get_variants(
    document: &kuchiki::NodeRef,
    parent: &doc::Item,
) -> anyhow::Result<(doc::ItemType, Vec<doc::MemberGroup>)> {
    let ty = doc::ItemType::Variant;
    let mut variants: Vec<doc::Doc> = Vec::new();
    let heading = select_first(document, &format!("#{}", ty.group_id()))?;

    let mut next = heading.and_then(|n| next_sibling_element(n.as_node()));
    let mut name: Option<String> = None;
    while let Some(element) = &next {
        if is_element(element, &markup5ever::local_name!("div")) {
            if has_class(element, ty.class()) {
                if let Some(name) = &name {
                    variants.push(doc::Doc::new(parent.name.child(name), ty));
                }
                name = get_node_attribute(element, "id")
                    .and_then(|s| s.splitn(2, '.').nth(1).map(ToOwned::to_owned));
            } else if has_class(element, "docblock") {
                if let Some(name) = &name {
                    let mut doc = doc::Doc::new(parent.name.child(name), ty);
                    // TODO: use inner_html() instead
                    doc.description = element.first_child().map(|n| n.text_contents());
                    variants.push(doc);
                }
                name = None;
            }

            next = element.next_sibling();
        } else {
            if let Some(name) = &name {
                variants.push(doc::Doc::new(parent.name.child(name), ty));
            }
            next = None;
        }
    }

    let mut groups: Vec<doc::MemberGroup> = Vec::new();
    if !variants.is_empty() {
        let mut group = doc::MemberGroup::new(None);
        group.members = variants;
        groups.push(group);
    }
    Ok((ty, groups))
}

fn get_members(
    document: &kuchiki::NodeRef,
    parent: &doc::Item,
    ty: doc::ItemType,
) -> anyhow::Result<Vec<doc::Doc>> {
    let mut members: Vec<doc::Doc> = Vec::new();
    if let Some(table) = select_first(document, &format!("#{} + table", ty.group_id()))? {
        let items = select(table.as_node(), "td:first-child :first-child")?;
        for item in items {
            let item_name = item.as_node().text_contents();
            let docblock = item.as_node().parent().and_then(|n| n.next_sibling());

            let mut doc = doc::Doc::new(parent.name.child(&item_name), ty);
            // We would like to use inner_html() here, but that is currently not implemented in
            // kuchiki
            doc.description = docblock.map(|n| n.text_contents());
            members.push(doc);
        }
    }
    Ok(members)
}

fn get_member(
    document: &kuchiki::NodeRef,
    name: &str,
) -> anyhow::Result<Option<kuchiki::NodeDataRef<kuchiki::ElementData>>> {
    select_first(document, &format!("#{}\\.v", name))
}

fn get_attribute(element: &kuchiki::ElementData, name: &str) -> Option<String> {
    element.attributes.borrow().get(name).map(ToOwned::to_owned)
}

fn get_node_attribute(node: &kuchiki::NodeRef, name: &str) -> Option<String> {
    node.as_element().and_then(|e| get_attribute(e, name))
}

fn next_sibling_element(node: &kuchiki::NodeRef) -> Option<kuchiki::NodeRef> {
    let mut next = node.next_sibling();
    while let Some(node) = &next {
        if node.as_element().is_some() {
            break;
        }
        next = node.next_sibling();
    }
    next
}

fn is_element(node: &kuchiki::NodeRef, name: &markup5ever::LocalName) -> bool {
    node.as_element()
        .map(|e| &e.name.local == name)
        .unwrap_or(false)
}

fn has_class(node: &kuchiki::NodeRef, class: &str) -> bool {
    node.as_element()
        .and_then(|e| get_attribute(&e, "class"))
        .map(|a| a.split(' ').any(|s| s == class))
        .unwrap_or(false)
}

fn get_html(node: &kuchiki::NodeRef) -> anyhow::Result<String> {
    let mut vec: Vec<u8> = Vec::new();
    node.serialize(&mut vec)?;
    String::from_utf8(vec).context("Could not convert node to HTML")
}

#[cfg(test)]
mod tests {
    use crate::doc;

    #[test]
    fn test_find_item() {
        let path = crate::tests::ensure_docs();
        let path = path.join("kuchiki").join("all.html");
        assert_eq!(None, super::find_item(&path, "foobar").unwrap());
        assert_eq!(
            Some("struct.NodeRef.html".to_owned()),
            super::find_item(&path, "NodeRef").unwrap()
        );
    }

    #[test]
    fn test_parse_item_doc() {
        let path = crate::tests::ensure_docs();
        let path = path.join("kuchiki").join("struct.NodeRef.html");
        let name: doc::Fqn = "kuchiki::NodeRef".to_owned().into();
        let item = doc::Item::new(name.clone(), path, doc::ItemType::Struct);
        let doc = super::parse_item_doc(&item).unwrap();

        assert_eq!(name, doc.name);
        assert_eq!(doc::ItemType::Struct, doc.ty);
        assert!(doc.definition.is_some());
        assert!(doc.description.is_some());
    }

    #[test]
    fn test_parse_member_doc() {
        let path = crate::tests::ensure_docs();
        let path = path.join("kuchiki").join("struct.NodeDataRef.html");
        let name: doc::Fqn = "kuchiki::NodeDataRef::as_node".to_owned().into();
        let item = doc::Item::new(name.clone(), path, doc::ItemType::Method);
        let doc = super::parse_member_doc(&item).unwrap();

        assert_eq!(name, doc.name);
        assert_eq!(doc::ItemType::Method, doc.ty);
        assert_eq!(
            "<code id=\"as_node.v\">\
             pub fn <a class=\"fnname\" href=\"#method.as_node\">as_node</a>(&amp;self) \
             -&gt; &amp;<a class=\"struct\" href=\"../kuchiki/struct.NodeRef.html\" \
             title=\"struct kuchiki::NodeRef\">NodeRef</a></code>",
            &doc.definition.unwrap()
        );
        assert!(doc.description.is_some());
    }
}
